import os
import re

pat1 = re.compile(r'Memory Working Set Current\s+=\s+([0-9]*\.[0-9]+|[0-9]+)\s+Mb, Memory Working Set Peak\s+=\s+([0-9]*\.[0-9]+|[0-9]+)\s+Mb')
pat2 = re.compile(r'MESH::Bricks: Total=([0-9]+)\s+Gas=([0-9]+)\s+Solid=([0-9]+)\s+Partial=([0-9]+)\s+Irregular=([0-9]+)')

def MFSP(src):
    res = pat1.findall(src)
    if res and len(res[0]) == 2:
        return float(res[0][1])
    else:
        return -1

def MESH(src):
    res = pat2.findall(src)
    if res and len(res[0]) == 5:
        return int(res[0][0])
    else:
        return -1

def toFixed(numObj, digits=0):
    return f"{numObj:.{digits}f}"

def regularOuput(outputText_,  *files):
    print(outputText_, end="")
    for file in files:
        file.write(outputText_)

def dirSetFilling(folderPath_):
    result = set()
    for k in os.walk(folderPath_):
        for l in range(len(k[2])):
            if k[2][l].endswith(".stdout") == True:
                result.add(os.path.relpath(os.path.join(k[0], k[2][l]), folderPath_))
    return result

def goodViewPath(path):
    return path.replace(os.sep, '/')

def folderExsistCheck (absFolderPath_, *dirs):
    for chekingFolder in dirs:
        if os.path.exists(os.path.join(absFolderPath_, chekingFolder)) != True:
            return chekingFolder
    return 0

def folderMatching (testFolderPath):
    ft_runFolderPath = os.path.join(testFolderPath, "ft_run")  # Абсолютный путь до папки ft_run текущего теста
    ft_referenceFolderPath = os.path.join(testFolderPath, "ft_reference")  # Абсолютный путь до папки ft_reference текущего теста
    ft_runDirs = dirSetFilling(ft_runFolderPath)  # Множество, содержащее подпапки ft_run
    ft_referenceDirs = dirSetFilling(ft_referenceFolderPath)  # Множество, содержащее подпапки ft_reference

    if ft_runDirs != ft_referenceDirs:  # Вывод в случае, если *.stdout файлы в ft_run и ft_reference не совпадают
        return list(ft_runDirs - ft_referenceDirs), list(ft_referenceDirs - ft_runDirs)
    return 0, list(ft_runDirs)

def ft_FileCheck (filePath_, type ):
    if type == 'ft_run':
        isFlag = 0
    nLine = 1
    runMaxim = -1
    runMESH = -1
    ft_File = open(filePath_, 'tr')
    for line in ft_File:
        if type == 'ft_run':
            if "ERROR" in line.upper():
                ft_File.close()
                return -3, filePath_, nLine, line,
            if line.startswith("Solver finished at"):
                isFlag = 1
            nLine = nLine + 1
        tmp1 = MFSP(line)
        if tmp1 > runMaxim:
            runMaxim = tmp1
            continue
        tmp2 = MESH(line)
        if tmp2 > 0:
            runMESH = tmp2

    ft_File.close()
    if type == 'ft_run':
        if isFlag == 0:
            return -4, filePath_, nLine, line
    return runMaxim, runMESH

def crossFileCheck(folderPath_, listOfDirs):
    result = ['0'*len(listOfDirs)]
    for k in range(len(listOfDirs)):
        tmp1 = ft_FileCheck(os.path.join(folderPath_, "ft_run", listOfDirs[k]), 'ft_run')
        if tmp1[0] == -3:
            result[k] = tmp1
            continue
        if tmp1[0] == -4:
            result[k] = tmp1
            continue
        tmp2 = ft_FileCheck(os.path.join(folderPath_, "ft_reference", listOfDirs[k]), 'ft_reference')
        dif1 = max(tmp1[0], tmp2[0]) / min(tmp1[0], tmp2[0])
        if dif1 > 4:
            result[k] = [-5, listOfDirs[k], tmp1[0], tmp2[0], dif1]
            continue
        dif2 = (max(tmp1[1], tmp2[1]) / min(tmp1[1], tmp2[1])) - 1
        if dif2 > 0.1:
            result[k] = [-7, listOfDirs[k], tmp1[1], tmp2[1], dif2]
            continue
        result[k] = [-8, listOfDirs[k]]
    return result

def oneTestCheck(folderPath_):
    tmp = folderExsistCheck(folderPath_, 'ft_run', 'ft_reference')
    if tmp != 0:
        return -1, tmp  # Возвращает флаг, показывающий, что на тесте отсутствует папка и имя этой папки
    tmp1, tmp2 = folderMatching(folderPath_)
    if tmp1 != 0:
        return -2, tmp1, tmp2  # Возвращает флаг, показывающий, что множества *.stdout файлов не одинаковы и оба множества
    tmp3 = crossFileCheck(folderPath_, tmp2)
    return tmp3

tmpList = [0, 0, 0]

logFolderPath = os.path.join(os.getcwd(), "logs")  # Абсолютный путь к папке log

f = open('reference_result.txt', 'tw')  # Файл, куда будем писать результаты тестов

tmpList[0] = f

for i in sorted(os.listdir(path=logFolderPath)):  # Основной цикл, пробегающий по всем подпапкам всех папок log
    firstSubfoldPath = os.path.join(logFolderPath, i)  # Абсолютный путь до 1-й подпапки
    for j in sorted(os.listdir(path=firstSubfoldPath)):
        secondSubfoldPath = os.path.join(firstSubfoldPath, j)  # Абсолютный путь до 2-й (текущей) папки
        relCurrentFolderPath = os.path.join(i, j)  # Относительный путь папки текущего теста (для вывода)
        currentOutputFile = os.path.join(secondSubfoldPath, "report.txt")  # Путь к промежуточному файлу вывода

        tmp = oneTestCheck(secondSubfoldPath)

        # print(tmp)

        if tmp[0] == -1:
            reportFile = open(currentOutputFile, 'tw')
            outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n" + "directory missing: " + \
                         tmp[1] + "\n"
            regularOuput(outputText, f, reportFile)
            reportFile.close()
            continue

        if tmp[0] == -2:
            reportFile = open(currentOutputFile, 'tw')
            step = 0
            outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n"
            for buff in [tmp[1], tmp[2]]:
                if len(buff) != 0:
                    if step == 0:
                        outputText = outputText + "In ft_run there are extra files files not present in ft_reference: "
                    elif step == 1:
                        outputText = outputText + "In ft_run there are missing files present in ft_reference: "
                    for m in range(len(buff)):
                        outputText = outputText + "'" + goodViewPath(buff[m]) + "'"
                        if m == (len(buff) - 1):
                            outputText = outputText + "\n"
                        else:
                            outputText = outputText + " "
                step = step + 1
            regularOuput(outputText, f, reportFile)
            reportFile.close()
            continue

        for k in range(len(tmp)):
            reportFile = open(currentOutputFile, 'tw')
            if tmp[k][0] == -3:
                outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n" + goodViewPath(os.path.relpath(tmp[k][1], os.path.join(secondSubfoldPath, 'ft_run')) + "(" + str(tmp[k][2]) + "): " + tmp[k][3])
                regularOuput(outputText, f, reportFile)
                reportFile.close()
                continue

            elif tmp[k][0] == -4:
                outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n" + goodViewPath(
                    os.path.relpath(tmp[k][1], os.path.join(secondSubfoldPath, 'ft_run')) + ": missing 'Solver finished at'\n")
                regularOuput(outputText, f, reportFile)
                reportFile.close()
                continue

            elif tmp[k][0] == -5:
                outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n" + goodViewPath(
                    tmp[k][1]) + ": different 'Memory Working Set Peak' (ft_run=" + str(
                    tmp[k][2]) + ", ft_reference=" + str(tmp[k][3]) + ", rel.diff=" + str(
                    round(tmp[k][4], 2)-1) + ", criterion=4)\n"
                regularOuput(outputText, f, reportFile)
                reportFile.close()
                continue

            elif tmp[k][0] == -7:
                outputText = "FAIL: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n" + goodViewPath(
                    tmp[k][1]) + ": different 'Total' of bricks (ft_run=" + str(tmp[k][2]) + ", ft_reference=" + str(
                    tmp[k][3]) + ", rel.diff=" + str(toFixed(tmp[k][4], 2)) + ", criterion=0.1)\n"
                regularOuput(outputText, f, reportFile)
                reportFile.close()
                continue

            elif tmp[k][0] == -8:
                outputText = "OK: " + goodViewPath(relCurrentFolderPath + os.sep) + "\n"
                regularOuput(outputText, f, reportFile)
                reportFile.close()
                continue

f.close()
